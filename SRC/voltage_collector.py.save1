from serial import Serial
import re
import threading
import errors as e
import random
import time
import sys
import math
import cgi
from operator import itemgetter
from functools import partial


class VoltageCollector(threading.Thread):

        def membership(value,center):
            #square root of square of value
            #DOM and deffuzification
            output = value*center
           #g_values.append(output)
           # result = sum([g_values[n] for n in range(0,len(g_values))])
            self.__m_bucket.append(output)
            #print(result)
            #outputTap(result)

        #GPIOS ACTIVATION
        def largeDown(gpio,value):
           # print("Tap Large Down.\n")
            path = '/sys/class/gpio/gpio' + gpio + '_pg4/value'
            f = open(path,'w')
            f.write(str(value))
            f.close()
            
             
        def down(gpio,value):
          #  print("Tap Down\n")
            path = '/sys/class/gpio/gpio' + gpio + '_pg3/value'
            f = open(path,'w')
            f.write(str(value))
            f.close()
         
        def noChange(gpio,value):
           # print("No Change Tap\n")
            path = '/sys/class/gpio/gpio' + gpio + '_pg1/value'
            f = open(path,'w')
            f.write(str(value))
            f.close()
         
        def up(gpio,value):
           # print("Tap Up\n")
            path = '/sys/class/gpio/gpio' + gpio + '_pg0/value'
            f = open(path,'w')
            f.write(str(value))
            f.close()

        def largeUp(gpio,value):
           # print("Tap Large Up \n")
            path = '/sys/class/gpio/gpio' + gpio + '_pg2/value'
            f = open(path,'w')
            f.write(str(value))
            f.close()
            
        #OUTPUT Ranging
        def outputTap(result):
            
            if result >= 60:
                print("tap 4")
                gpio1=int(4)
                gpio=str(gpio1)
                value=1
                largeDown(gpio,value)
            else:
                gpio1=int(4)
                gpio=str(gpio1)
                value=0
                largeDown(gpio,value)
                
            if result > 20 and result < 60:
                print("tap 3")
                gpio1=int(5)
                gpio=str(gpio1)
                value=1
                down(gpio,value)
            
            else:
                gpio1=int(5)
                gpio=str(gpio1)
                value=0
                down(gpio,value)
                
                
            if result >= -20 and result <=20:
                print("tap 2")
                gpio1=int(6)
                gpio=str(gpio1)
                value=1
                noChange(gpio,value)
            
            else:
                gpio1=int(6)
                gpio=str(gpio1)
                value=0
                noChange(gpio,value)
                  
            if result > -60 and result < -20:
                print("tap 1")
                gpio1=int(7)
                gpio=str(gpio1)
                value=1
                up(gpio,value)
            else:
                gpio1=int(7)
                gpio = str(gpio1)
                value=0
                up(gpio,value)
                
            if result < -60 :
                print("tap 0")
                gpio1=int(8)
                gpio=str(gpio1)
                value=1
                largeUp(gpio,value)

            else:
                gpio1=int(8)
                gpio=str(gpio1)
                value=0
                largeUp(gpio,value)
                
        def trap(a, b, c, d, error):
            first = (error - a) / (b - a)
            second = (d - error) / (d - c)
            return( max(min(first, 1., second), 0.))

        #input definition
        


        def __init__(self, p_thread_id, p_portname, p_path):
                threading.Thread.__init__(self)
                self.__m_thread_id = p_thread_id
                self.__m_portname = p_portname
                self.__m_path = p_path
                self.__m_serial = Serial(self.__m_path, baudrate=9600, bytesize=8, parity='N', stopbits=1, timeout=None)
                self.__m_bucket = []
                #self.__m_fuzzify = fuzzification(error)
                
        def fuzzification(self,error):
            
            largeNeg = trap(-51,-50,-6,-5,error)
            if largeNeg > 0:
                centerVal = -100
                print("LN = ", largeNeg)
                membership(largeNeg,centerVal)
                
            #def neg(x):
            neg = trap(-6,-5,-3,-2,error)
            if neg > 0:
                centerVal = -50
                print("N = ", neg)
                membership(neg,centerVal)

            #def zero(x):
            zero = trap(-3,-2,2,3,error)
            if zero > 0:
                centerVal = 0
                print("Z = ", zero)
                membership(zero,centerVal)

            #def positive(x):
            positive = trap(2,3,5,6,error)
            if positive > 0:
                centerVal = 50
                print("P = ",positive)
                membership(positive,centerVal)

            #def largePos(x):
            largePos = trap(5,6,50,51,error)
            if largePos > 0:
                centerVal = 100
                print("LP = ",largePos)
                membership(largePos,centerVal)
                
        def run(self):
                while True:
                        #number = random.uniform(1,100)
                        #self.__m_bucket.append(number)
                        #print (str(self.__m_thread_id) + " generated: " + str(number))
                        #time.sleep(5)
                        try:
                                raw_data = self.__m_serial.readline(self.__m_serial.inWaiting()).decode('utf-8')[:-2]
                                if raw_data:
                                        list_of_val = raw_data.split(",")
                                        voltage = float(list_of_val[5])
                                        error = 220 - voltage
                                        self.fuzzification(error)
                                        #self.__m_bucket.append(voltage)
                        except (Exception) as err:
                                print("Error:" + str(err))
                                #time.sleep(5)
                self.__m_serial.close()

        
        def getValue(self):
                if len(self.__m_bucket) == 0:
                        raise e.E_NoValue()
                return self.__m_bucket.pop(0)
